#include <stdio.h>

int main(void) {
    printf("%f\n", 0.12312535435); //기본적으로 실수 출력 시 6소수점 6자리까지만 출력한다.
    printf("%10.4f\n", 984928.12312312345); //10자리 중에서 소수점 이하를 4자리로 하라는 것.
    printf("%e\n", 0.2342341342342);
    printf("%g\n", 0.2342341342342);
    printf("%g\n", 0.2342); //이거 왜 안되는 거지? 그냥 6자리이상이면 잘라버리는 현상이 발생

    float x = 1.2354535908874234;
    double y = 1.239475849384953543;

    printf("float의 크기 = %d\n", sizeof(float));
    printf("double의 크기 = %d\n", sizeof(double));

    printf("x = %30.25f\n", x); //float형의 변수인 x의 경우, 소수점 8자리 이하부터는 이상하게 출력 -> float형의 경우, 유효 숫자가 대략 처음 6자리이기 때문
    printf("y = %30.25f\n", y); /* double형의 경우에는 소수점 이하 16자리까지는 비교적 정확하게 표현됨을 알 수 있다.
     하지만 부동소수점형의 변수들은 유효숫자의 제한이 있기 때문에 정수처럼 실수를 완벽하게 표현하지 못한다는 점이다.
     부동 소수점형은 오차가 존재할 수 있다. */

    float a = 1e39;
    printf("x = %e\n", a);

    return 0;
}
