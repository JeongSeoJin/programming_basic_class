//18, December, 2024

#include <stdio.h>

int main(void) {
    printf("%f\n", 0.12312535435); //기본적으로 실수 출력 시 6소수점 6자리까지만 출력한다.
    printf("%10.8f\n", 984928.12312312345); //10자리 중에서 소수점 이하를 4자리로 하라는 것.
    printf("%e\n", 0.2342341342342);
    printf("%g\n", 0.2342341342342);
    printf("%g\n", 0.2342); //이거 왜 안되는 거지? 그냥 6자리이상이면 잘라버리는 현상이 발생

    float x = 1.2354535908874234;
    double y = 1.239475849384953543;

    printf("float의 크기 = %d\n", sizeof(float));
    printf("double의 크기 = %d\n", sizeof(double));

    printf("x = %30.25f\n", x); //float형의 변수인 x의 경우, 소수점 8자리 이하부터는 이상하게 출력 -> float형의 경우, 유효 숫자가 대략 처음 6자리이기 때문
    printf("y = %30.25f\n", y); /* double형의 경우에는 소수점 이하 16자리까지는 비교적 정확하게 표현됨을 알 수 있다.
     하지만 부동소수점형의 변수들은 유효숫자의 제한이 있기 때문에 정수처럼 실수를 완벽하게 표현하지 못한다는 점이다.
     부동 소수점형은 오차가 존재할 수 있다. */

    //overflow, underflow
    //float형의 변수의 크기는 약 1e38~1e-38정도인데 이것보다 크거나 작으면 오버플로우, 언더플로우 현상이 발생한다.
    float a = 1e39;
    float b = 1.23456e-48;
    printf("a = %e\nb = %e\n", a, b);

    //부동소수점형의 부정확성
    float value = 0.1;
    printf("%.20f\n", value); //0.1의 값이 정확하게 출력되지 않는 모습을 보인다.

    double k = 0;

    k = (1.0e20 + 5.0)-1.0e20;
    printf("k = %lf\n", k); //double형의 유효숫자도 최대가 약 16자리정도이기 때문에 1.0e20정도를 계산할 때 필요한 유효숫자가 적어도 20자리인 것에 비해 너무 작기 때문에 5.0을 0으로 처리해버린다.
    k = (1.0e10 + 5.0)-1.0e10;
    printf("k = %lf\n", k); //이와 같이 유효숫자에 포괄될 수 있는 수라면 5.0이 정확히 표현되는 것을 볼 수 있다.

    return 0;
}
