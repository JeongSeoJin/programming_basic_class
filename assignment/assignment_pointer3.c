#include <stdio.h>

int main(void) {
    int A[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // 리스트 초기화
    int *p = NULL; // NULL pointer 선언 -> 인덱스를 사용하지 않고 포인터를 사용하기 위하여
    p = A; // A의 주소를 포인터에 대입. (배열의 이름은 근본적으로 포인터와 동일)
    // cf) 여기서 p가 가리키는 주소는 배열의 주소인데 이는 0번째 인덱스에 있는 값의 주소와 동일하다.

    /*p가 가리키는 객체의 주소에 + 1씩 하며 *를 이용해 역참조 한 후에 p가 가리키는 객체
    를 출력하는 코드. 즉 이 코드는 A 배열의 원소들을 0번째 인덱스부터 9번째 인덱스까지 하나하나 출력함.
    */ 
    for (int i = 0; i < 10; i ++) {
        printf("%d ", *(p + i));
    } 

    printf("\n"); // 줄바꿈을 위한 개행문자 출력

    /*기존에 있던 배열의 값을 역순으로 출력하기 위해서는 위의 코드와 조금은 다른 모습으로 작성해야함.
    위의 코드에서는 순차적으로 출력하기 위해서 P가 가리키는 객체의 주소를 1씩 증가시키며 출력했다.
    때문에 연순으로 출력하기 위해서는 위의 주소를 9번째 인덱스부터 하나씩 감소시키며 출력을 수행하면
    기존의 배열을 역순으로 출력할 수 있도록 해주는 알고리즘을 구현할 수 있다.*/ 
    for (int i = 0; i < 10; i ++) {
        printf("%d ", *(p + 9 - i));
    }

    /* 위에서 말했듯이 *(p+9)는 배열 A의 9번 째 인덱스에 있는 값을 의미한다. 때문에 이 값부터
    주소에 -1씩 해가며 값을 출력하면 기존의 배열에 있는 원소들이 역순으로 출력되는 것을 알 수 있다. */

    return 0;
}